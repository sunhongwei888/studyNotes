### 几个概念

#### 1、共享锁和排他锁

共享锁和排他锁，通常用于处理并发读或者并发写的场景。又叫读锁和写锁

读锁是共享的，或者说是互相不阻塞的。多个用户可以同时读取一个资源，互不干扰。

写锁是排他的，一个写锁会阻塞其他的写锁和读锁，这是出于安全策略的考虑，确保只能有一个用户写数据，并防止其他用户读取正在写入的数据。

#### 2、锁的粒度：表锁与行锁

一种提高共享资源并发性的方式就是让锁定的对象更具有选择性，尽量保证锁定需要修改的部分数据，而不是全部数据。比如CurrentHashMap的分段锁思想，只锁定那一段的数据，并不影响其他段数据的写入和读取。这样能极大提高系统的并发性。

表锁：锁住整张表。

- 读锁是互不阻塞的
- 一个用户对表进行更新（插入、删除、更新）时，需要先获得写锁，对表更新期间，会阻塞其他用户的对该表的读写操作。

行级锁：只会锁住特定的行，InnoDB存储引擎实现了行级锁。能够最大程度的支持并发处理。

#### 2、事务的隔离级别

- READ UNCOMMITTED（未提交读）：一个事务，即使没有提交，他的修改对其他事务也是可见的
- READ COMMITTED  （提交读）：一个事务，它提交之后，它的修改对其他事务才可见
- REPEATABLE READ（可重复读）：MYSQL默认的事务隔离级别。保证一个事务中，多次读取同样的数据结果一致
- SERIALIZABLE（串行化）：事务串行化执行，在读取的每一行数据都加上锁，锁的开销很大，效率极低。基本不用

并发事务导致的问题：

- 脏读：READ UNCOMMITTED会造成脏读，T1读取了T2更新但是还没有提交的数据。如果T2回滚了，那么T1读取的数据就是临时且无效的数据

- 不可重复读：T1读取数据，T2更新了数据，T1再读取数据就不一样了

- 幻读：T1读取了一张表的数据，之后T2插入了一些行，之后T1再读取这个表的数据就会多出来几行

| 隔离级别         | 脏读 | 不可重复读 | 幻读 | 加锁读 |
| ---------------- | ---- | ---------- | ---- | ------ |
| READ UNCOMMITTED | YES  | YES        | YES  | NO     |
| READ COMMITTED   | NO   | YES        | YES  | NO     |
| REPEATABLE READ  | NO   | NO         | YES  | NO     |
| SERIALIZABLE     | NO   | NO         | NO   | YES    |

#### 3、死锁

两个事务T1和T2

```mysql
#事务T1
UPDATE student SET class='java班' WHERE name='张三'
UPDATE student SET class='java班' WHERE name='李四'

#事务T2
UPDATE student SET class='python班' WHERE name='李四'
UPDATE student SET class='python班' WHERE name='张三'
```

如果凑巧，都执行了第一行语句，更新了一条数据， 同时锁定了改行数据，然后事务T1和T2尝试执行第二条更新语句，却发现该行已经被对方锁定了。

两个事务都等待对方释放锁，同时又持有对方需要的锁，则陷入死循环。

InnoDB处理死锁的方式是，将持有最少行级排他锁的事务进行回滚。

4、选择合适的存储引擎



### 优化数据类型

1. 更小的通常更好：尽量选择能够正确存储数据的最小的数据类型，它占用更少的磁盘，内存和CPU缓存，并且处理时占用的CPU周期更少
2. 简单就好：整型比字符串的操作代价更低
3. 尽量避免NULL：如果准备在列上建立索引，一定要避免列的值为NULL。
   -  如果查询中包含可为NULL的列，对MYSQL来说更难优化。因为可为NULL的列使得索引、索引统计和值比较都更复杂。
   - 可为NULL的列会占用更多的存储空间，Mysql里也会特殊处理
   - 可为NULL的列被索引时，每个索引记录需要一个额外的字节
   - 通常吧可为NULL的列改成NOT NULL带来的性能提升比较小！所以没必要在现有的表中特意修改它，除非确定它会导致问题。但是在创建表时，如果准备在某个列上建索引，一定要避免列的值为NULL

#### 整数类型

| 类型         | TINYINT | SMALLINT | MEDIUMINT | INT  | BIGINT |
| ------------ | ------- | -------- | --------- | ---- | ------ |
| 占用存储空间 | 8       | 16       | 24        | 32   | 64     |

整数类型可以设置成UNSIGNED属性，表示不允许负值

TINYINT UNSIGNED可以存储的范围时0-255，TINYINT存储范围时-128~127，他们使用相同大小的存储空间。

注意：MYSQL可以为整数类型指定宽度，然而这种操作对于存储和计算来说并没有任何影响。

**INT(1)和INT(20)无论是在存储和计算上，都是一样的。插入的时候都会插入一个在INT范围内的数**

#### 字符串类型

CHAR与VARCHAR区别

VARCHAR存储可变长度字符串，它比CHAR定长字符串更节省空间（越短的字符串使用越少的空间），VARCHAR使用1个或2个额外字节记录字符串长度。小于等于255字节使用1个字节表示，否则使用2个字节表示

CHAR存储定长字符串。MYSQL根据字符串长度分配固定的存储空间，会删除末尾空格。'str ' 在CHAR中存储'str'，而在VARCHAR中存储'str '

注：只分配需要的空间，避免浪费更多的内存

#### 日期时间类型

DATETIME和TIMESTAMP

DATETIME：保存时间范围1001年到9999年，精确到秒。与时区无关，使用8个字节的存储空间

TIMESTAMP：保存范围1970到2038年。保存的是从1970年1月1日到现在的秒数，只使用4个字节的存储空间。且不受时区限制。

注：能使用TIMESTAMP尽量使用，因为它比DATETIME空间效率更好

### 索引

