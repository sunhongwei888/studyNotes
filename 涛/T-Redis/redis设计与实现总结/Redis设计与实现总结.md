## Redis底层数据结构实现

数据库的键总是一个字符串对象，数据库的值可以是字符串、列表、哈希、集合对、有序集合对象5种对象。

### 简单动态字符串SDS

#### 1、什么是SDS？

Redis没有直接使用C语言的传统字符串，而是构建了一种简单动态字符串（Simple dynamic string， SDS）的抽象类型，Redis中的字符串底层都是使用SDS结构进行存储，比如包含字符串的键值对底层都是使用SDS结构实现的。

比如：set msg "hello redis" 向redis中插入一条字符串对象。键和值都是字符串。键msg对象的底层实现是一个保存着字符串msg的SDS。值hello redis对象的底层实现也是一个保存着字符串hello redis的SDS

SDS不仅用来保存字符串值，SDS还在缓冲区中有重要的作用：AOF缓冲区，客户端的输入缓冲区底层实现都是使用SDS

SDS结构定义在sds.h中

```c
struct sdshdr{
    int len;//SDS保存的字符串长度
    int free;//buf数组中未使用字节数量
    char buf[];//字符数组，保存字符串
}
```

![](images/79800085.jpg)

最后一个字节保存了空字符'\0'，保留了C字符串的规范，使得SDS结构的字符串，可以重用一部分C函数库的函数。

#### 2、为什么redis定制了SDS结构，而不使用C字符串呢？

主要是因为C字符串有以下缺点：

- 获取字符串长度时间复杂度为O(N)：C字符串获取长度需遍历整个字符串，遇到'\0'空字符为止。
- 缓冲区溢出：比如在进行字符串追加操作时，如果没有分配足够的内存，就会造成内存溢出。
- 内存重分配：每次增长或者截短字符串，程序都要对保存C字符串的数组进行内存重分配操作，而内存重分配涉及复杂的算法，并可能需要执行系统调用，所以它通常比较耗时。
- 空字符问题：C字符串中间不能保存空格，否则程序遍历是会误认为是字符串的末尾。这一限制导致C字符串只能存储文本数据，不能保存像图片、音视频、压缩文件等二进制数据。

SDS是通过怎样的设计解决C字符串的问题呢？

1、SDS通过len属性记录了SDS长度，所以获取长度的时间复杂度为O(1)，即strlen命令的时间复杂度是O(1)

2、SDS空间分配策略避免了缓冲区溢出：当对SDS进行修改时，会先检查SDS空间是否满足修改，不满足会自动扩展到所需大小，然后才执行修改。

3、较少修改字符串时内存重分配次数：SDS中的free记录buf字节数组中未使用的字节。redis通过free属性实现空间预分配、惰性空间释放两种优化策略。

- 空间预分配：当对SDS进行增长操作时，程序不仅会分配修改所必须得空间，还会为SDS分配额外的未使用空间。通过预分配策略，减少了连续执行字符串增长操作时内存重分配次数。
- 惰性空间释放：当对SDS进行截短操作时，程序并不会立即回收缩短后多出来的字节所占用的内存，而是使用free属性记录多出来的字节数，以供将来使用。如果将来要对这个SDS进行增长操作，未使用空间可能就派上用场，并且增长操作也不一定会执行内存重分配。

4、SDS结构中的buf字节数组，是二进制安全的，不仅可以保存字符，也可以保存二进制数据。

5、SDS保留了C字符串的惯例，将数据的末尾设置为空字符'\0'，SDS中之所以保留这一规范是可以重用C字符串函数库的一部分函数，例如追加字符串。

------

### 链表

链表提供了顺序性的节点访问。列表的底层实现之一就是链表。当列表中包含较多元素，或者列表中包含的元素都是较长的字符串时，redis就会使用链表作为列表的底层实现。

每个链表的节点使用listNode结构表示

```c
typedef stuct listNode{
    struct listNode *prev;//前置节点
    struct listNode *next;//后置节点
    void *value;//节点的值
}
```

而多个listNode可以通过prev和next指针构成双端链表

![](images/graphviz-167adfc2e52e078d4c0e3c8a9eddec54551602fb.png)

并且redis中使用list来持有链表，方便操作

```c
typedef struct list{
    listNode *head;//头结点
    listNode *tail;//尾节点
    unsigned long len;//链表包含节点数量
}
```

由list结构和listNode组成的链表

![](images/graphviz-5f4d8b6177061ac52d0ae05ef357fceb52e9cb90.png)

redis实现的链表总结：

- 无环链表：表头节点的prev指针和表尾节点的next指针指向的都是NULL，对链表的访问以NULL为终点
- 通过list结构的head指针和tail指针，访问链表头尾节点的时间复杂度为O(1)
- 通过list结构的len属性，程序获取链表节点数量的时间复杂度为O(1)

------

### 字典

字典是一种用于保存键值对的抽象数据结构。比如set msg "hello redis"这个键值对就是保存在数据库字典中

字典还是哈希键的底层实现之一，当一个哈希键包含的键值对比较多，又或者键值对中的元素都是比较长的字符串时，redis就会使用字典作为哈希键的底层实现。

redis中的字典使用哈希表作为底层实现，一个哈希表中可以有若干个哈希表节点

字典结构定义

```c
typedef struct dict{
    dictht ht[2];//哈希表，分为h[0],h[1]哈希表，通常情况下使用h[0]，h[1]用于rehash
    itn trehashidx;//rehash索引，当rehash完成时，值为-1
}
```

哈希表结构定义

```c
typedef struct dictht{
    dictEntity **table;//哈希表数组，数组中的每个元素对应一个dictEntity
    unsigned long size;//哈希表大小，table数组长度
    unsigned long sizemark;//=size-1，这个熟悉和哈希值一起决定一个键应该被放到table数组的哪个索引上
    unsigned long used;//哈希表已有节点的数量
}
```

哈希表节点结构定义

```c
typedef struct dictEntity{
 	void *key;//键
    //值
    union{
        void *val;
        unit64_t u64;
        int64_t s64;
    } v;
    struct dictEntity *next;//发生哈希冲突时使用。指向下一个哈希表节点，形成链表
}
```

redis的哈希表使用链地址法解决哈希冲突：当发生哈希冲突时（两个键通过计算得出的索引值相同），通过单链表维护这种关系（多个哈希表节点通过next指针构成一个单向链表，新节点总是添加到链表的表头位置）。

例如：键k0和k1计算得出的索引值都是2，由单链表解决哈希冲突，新的键k1添加到链表的表头

![](D:\rongtao7\Desktop\redis设计与实现总结\images\4.png)

字典-哈希表-哈希节点的对应关系

![](D:\rongtao7\Desktop\redis设计与实现总结\images\5.png)

向字典中添加一个元素的过程：

1. 通过字典的哈希函数，计算出key的hash值
2. 根据hash值和哈希表的sizemark属性计算出索引值：index=hash & dict -> ht[x].sizemark（ht[0]或ht[1]）
3. 根据索引值插入到哈希表数组中

#### rehash的步骤？

哈希表保存的键值对会增多或者减少，为了让哈希表的负载因子维持在一个合理的范围内（0.1=<load factory<1），当哈希表保存的键值对太多或者太少时，程序需要对哈希表进行扩容或者收缩。扩容和收缩都是通过rehash完成

1. 为字典的ht[1]哈希表分配空间，这个哈希表的空间大小取决于要执行的是扩容还是收缩操作，以及ht[0]包含的键值对数量（ht[0].used属性的值）
   - 扩容：ht[1]大小等于第一个大于等于ht[0].used  * 2的n次幂
   - 收缩：ht[1]大小等于第一个大于等于ht[0].used的2的n次幂
2. 将保存在ht[0]上的所有键值对rehash到ht[1]上面：rehash得过程是重新计算hash值以及索引值，然后根据索引值插入到ht[1]哈希表的指定索引上
3. 当ht[0]所有键值对都rehash到ht[1]上后，释放ht[0]，将ht[1]设置为ht[0]，并新建一个空白的哈希表作为ht[1]

#### 哈希表什么情况下会扩容和收缩？也就是什么情况下会rehash？

哈希表负载因子计算公式：

load_factory = ht[0].used / ht[0].size	(负载因子 = 哈希表已保存节点数量 / 哈希表大小)

1. 扩容
   - 程序没有执行BGSAVE命令或者BGREWRITEAOF(AOF重写)命令，并且哈希表的负载因子大于等于1
   - 如果程序正在执行BGSAVE或者BGREWRITEAOF(AOF重写)命令并且哈希表的负载因子大于等于5。在执行RDB或者AOF重写操作时，redis会创建当前服务器的子进程执行相应操作，为了避免在子进程存在期间对哈希表进行扩展操作，将扩展因子提高。可以避RDB或者AOF重写时不必要的内存写入操作，最大限度的节约内存。
2. 收缩：负载因子小于0.1进行收缩

#### 什么是渐进式rehash？为什么redis使用渐进式rehash？

扩展和收缩需要将ht[0]上的所有键值对rehash到ht[1]哈希表中。但是redis的rehash动作并不是一次性完成的，而是分多次、渐进式的完成的。

为什么不是一次性的完成呢？如果哈希表中保存的键值对数量很少，那么服务器在瞬间就可以将这些键值对全部rehash到ht[1]，但是如果哈希表中保存的是百万、千万甚至亿级别的键值对数量，如果一次性将这些键值对全部rehash到ht[1]，庞大的计算量可能会导致服务器在一段时间内停止服务。

渐进式rehash步骤：

1. 为ht[1]分配空间
2. 将字典中的rehashidx设置为0，表示rehash正式开始，rehash期间，不会阻塞CRUD等操作
3. 当ht[0]所有的键值对都rehash到ht[1]时，将rehashidx属性设置成-1，表示rehash完成

渐进式rehash期间执行CRUD时的哈希表操作

渐进式rehash的过程中，字典同时使用ht[0],ht[1]两个哈希表，渐进式rehash期间，字典的删除、查找、更新操作会在2个哈希表上进行。譬如：查找一个键时，现在ht[0]查找，ht[0]没有找到去ht[1]查找。但是，在渐进式rehash期间，新添加到字典的键值对会保存到ht[1]哈希表中，而ht[0]中不会做任何操作，保证ht[0]只减不增，否则会增加rehash的时间。

### 跳跃表

跳跃表是一种有序的数据结构，他通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。跳跃表的效率可以和平衡树相媲美，而且跳跃表的实现比平衡树简单的多。

Redis使用跳跃表作为有序集合键的底层实现之一，如果一个有序集合包含的元素数量较多，又或者有序集合的中的元素是比较长的字符串时，redis使用跳跃表作为有序集合键的底层实现

