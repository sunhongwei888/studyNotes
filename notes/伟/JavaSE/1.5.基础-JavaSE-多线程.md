# 简介

## 普通方法调用和多线程

![image-20220712101211393](G:\Agogogo2022\project\studyNotes\notes\伟\JavaSE\pictures\image-20220712101211393.png)

## 程序.进程.线程

在操作系统中运行的**程序就是进程**，比如你的QQ，播放器，游戏，IDE等等。。。。

**一个进程可以有多个线程**，如视频中同时听声音，看图像，看弹幕，等等

- 说起进程，就不得不说下**程序**。程序是指令和数据的有序集合，其本身没有任何运行的含义，是一个静态的概念。
- 而**进程**则是执行程序的一次执行过程，它是一个动态的概念。是系统资源分配的单位
- 通常在一个进程中可以包含若干个线程，当然一个进程中至少有一个线程，不然没有存在的意义。线程是CPU调度和执行的的单位。

**注意：很多多线程是模拟出来的，真正的多线程是指有多个cpu，即多核，如服务器。如果是模拟出来的多线程，即在一个cpu的情况下，在同一个时间点，cpu只能执行一个代码，因为切换的很快，所以就有同时执行的错局。**

## 总结

- 线程就是独立的执行路径；
- 在程序运行时，即使没有自己创建线程，后台也会有多个线程，如主线程，gc线程；
- main() 称之为主线程，为系统的入口，用于执行整个程序；
- 在一个进程中，如果开辟了多个线程，线程的运行由调度器安排调度，调度器是与操作系统紧密相关的，先后顺序是不能认为的干预的。
- 对同一份资源操作时，会存在资源抢夺的问题，需要加入并发控制；
- 线程会带来额外的开销，如cpu调度时间，并发控制开销。
- 每个线程在自己的工作内存交互，内存控制不当会造成数据不一致

# 线程创建

## 三种创建方式

- Thread class：**继承Thread类**
- Runnable接口：**实现Runnable接口**
- Callable接口：**实现Callable接口**

## Thread

- 自定义线程类继承Thread类
- 重写run()方法，编写线程执行体
- 创建线程对象，调用start()方法启动线程

```java
public class TestThread extends Thread{
    @Override
    public void run() {
        for (int i = 0; i < 20; i++) {
            System.out.println("我在看代码"+i);
        }
    }

    public static void main(String[] args) {
        TestThread testThread = new TestThread();
        //直接调用start方法
        testThread.start();

        for (int i = 0; i < 2000; i++) {
            System.out.println("我在学习多线程"+i);
        }
    }
}
```

## Runnable

- 自定义实现类实现Runnable接口
- 实现run()方法，编写线程执行体
- 创建线程对象，调用start()方法启动线程

```java
public class TestThread3 implements Runnable{
    @Override
    public void run() {
        for (int i = 0; i < 20; i++) {
            System.out.println("我在看代码"+i);
        }
    }

    public static void main(String[] args) {
        TestThread3 testThread = new TestThread3();
        //代理线程类调用start方法
        new Thread(testThread).start();

        for (int i = 0; i < 2000; i++) {
            System.out.println("我在学习多线程"+i);
        }
    }
}
```

**推荐使用Runnable对象，因为java单继承的局限性**

## thread+runnable小结

- 继承Thread类
  - 子类继承Thread类具备多线程能力
  - 启动线程：子类对象.start()
  - 不建议使用：避免oop单继承局限性
- 实现Runnable接口
  - 实现接口Runnable具有多线程能力
  - 启动线程：Thread(目标对象).start()
  - 推荐使用：避免单继承局限性，灵活方便，方便同一对象被多个线程使用

```java
//一份资源
StartThread station = new StartThread();

//多个代理
new Thread(station,"张三").start();
new Thread(station,"李四").start();
new Thread(station,"王二").start();
```

## Callable

### Runnable和Callable的区别

- Callable规定的方法是call(),Runnable规定的方法是run().
- Callable的任务执行后可返回值，而Runnable的任务是不能返回值
- call方法可以抛出异常，run方法不可以
- 运行Callable任务可以拿到一个Future对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过Future对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果。

### 概述

Callable和Runnable一样代表着任务，区别在于Callable有返回值并且可以抛出异常。其使用如下：

```java
public class CallableDemo {
 
    static class SumTask implements Callable<Long> {
 
        @Override
        public Long call() throws Exception {
 
            long sum = 0;
            for (int i = 0; i < 9000; i++) {
                sum += i;
            }
 
            return sum;
        }
    }
 
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        System.out.println("Start:" + System.nanoTime());
        FutureTask<Long> futureTask = new FutureTask<Long>(new SumTask());
        Executor executor=Executors.newSingleThreadExecutor();
        executor.execute(futureTask);
        System.out.println(futureTask.get());
        System.out.println("End:" + System.nanoTime());
    }
 
}
```

从上面的代码可以看到，使用到了一个FutureTask的变量并且还可以得到Callable执行的结果，那么这个FutureTask是什么呢?

### 分析

#### Future接口

Future是一个接口，代表了一个异步计算的结果。接口中的方法用来检查计算是否完成、等待完成和得到计算的结果。当计算完成后，只能通过get()方法得到结果，get方法会阻塞直到结果准备好了。如果想取消，那么调用cancel()方法。其他方法用于确定任务是正常完成还是取消了。一旦计算完成了，那么这个计算就不能被取消。

#### FutureTask类

FutureTask类实现了RunnableFuture接口，而RunnnableFuture接口继承了Runnable和Future接口，所以说FutureTask是一个提供异步计算的结果的任务。 
FutureTask可以用来包装Callable或者Runnbale对象。因为FutureTask实现了Runnable接口，所以FutureTask也可以被提交给Executor（如上面例子那样）。

#### FutureTask的状态

FutureTask中有一个表示任务状态的int值，初始为NEW。定义如下：

```java
private volatile int state;
private static final int NEW          = 0; //任务新建和执行中
private static final int COMPLETING   = 1; //任务将要执行完毕
private static final int NORMAL       = 2; //任务正常执行结束
private static final int EXCEPTIONAL  = 3; //任务异常
private static final int CANCELLED    = 4; //任务取消
private static final int INTERRUPTING = 5; //任务线程即将被中断
private static final int INTERRUPTED  = 6; //任务线程已中断
```

**总结下，FutureTask的状态流转过程，可以出现以下四种情况：**

1.  任务正常执行并返回。 NEW -> COMPLETING -> NORMAL
2.  行中出现异常。NEW -> COMPLETING -> EXCEPTIONAL
3.  任务执行过程中被取消，并且不响应中断。NEW -> CANCELLED
4.  任务执行过程中被取消，并且响应中断。 NEW -> INTERRUPTING -> INTERRUPTED

#### 构造方法　

```java
public FutureTask(Callable<V> callable) {
    if (callable == null)
        throw new NullPointerException();
    this.callable = callable;
    this.state = NEW;       // ensure visibility of callable
}

public FutureTask(Runnable runnable, V result) {
    this.callable = Executors.callable(runnable, result);
    this.state = NEW;       // ensure visibility of callable
}
```

第一个构造方法好理解；第二个方法是将Runnbale和结果组合成一个Callable，这个可以通过Excutors.callable()方法得出结论：

```java
 public static <T> Callable<T> callable(Runnable task, T result) {
     if (task == null)
         throw new NullPointerException();
     return new RunnableAdapter<T>(task, result);
 }
 
static final class RunnableAdapter<T> implements Callable<T> {
    final Runnable task;
    final T result;
    RunnableAdapter(Runnable task, T result) {
        this.task = task;
        this.result = result;
    }
    public T call() {
        task.run();
        return result;
    }
}
```

从上面可以看到RunnableAdapter实现了Callable并且在call方法中调用了Runnable的run方法，然后将结果返回，这其实就是一个适配器模式啊。 
所以说两个构造方法最终都是得到了一个Callable以及设置了初始状态为NEW。

#### run方法

```java
public void run() {
    //如果状态不为NEW或者CAS当前执行线程失败，直接返回
    if (state != NEW ||
        !UNSAFE.compareAndSwapObject(this, runnerOffset,
                                     null, Thread.currentThread()))
        return;
    //尝试调用Callable.call
    try {
        Callable<V> c = callable;
        if (c != null && state == NEW) {
            V result;
            boolean ran;
            try {
                result = c.call();
                ran = true;
            } catch (Throwable ex) {
                //出现异常了，调用setException方法
                result = null;
                ran = false;
                setException(ex);
            }
            //如果成功了，调用set方法
            if (ran)
                set(result);
        }
    } finally {
        // runner must be non-null until state is settled to
        // prevent concurrent calls to run()
        runner = null;
        // state must be re-read after nulling runner to prevent
        // leaked interrupts
        //如果在执行过程，任务被取消了
        int s = state;
        if (s >= INTERRUPTING)
            handlePossibleCancellationInterrupt(s);
    }
}
```

从上面可以看到，任务可以被执行的前提是当前状态为NEW以及CAS当前执行线程成功，也就是runner值，代表执行Callable的线程。从这个看到run方法就是调用Callable的call方法，然后如果出现异常了就调用setException方法，如果成功执行了，那么调用set方法，下面我们分别来看这几种情况。

#### set方法

当Callable成功执行后，会调用set方法将结果传出。源码如下：

```java
protected void set(V v) {
    //完成NEW->COMPLETING->NORMAL状态转换
    if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) {
        outcome = v;
        UNSAFE.putOrderedInt(this, stateOffset, NORMAL); // final state
        finishCompletion();
    }
}
```

从上面可以看到，将outcome变量赋值为结果，并将state状态更新，最后调用finishCompletion()方法。finishCompletion()方法将移除和通知所有等待线程，这个方法后面再说。下面先看setException方法。

#### setException方法

setException方法如下：

```java
//完成NEW->COMPLETING->EXCEPTIONAL状态转换
protected void setException(Throwable t) {
    if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) {
        outcome = t;
        UNSAFE.putOrderedInt(this, stateOffset, EXCEPTIONAL); // final state
        finishCompletion();
    }
}
```

从上面看到，该方法和set方法类似，完成状态转换，将结果设置为Throwable并调用finishCompletion通知和移除等待线程。

#### get方法

当想得到FutureTask的结算结果时，调用get方法，get方法可以允许多个线程调用，下面的例子展示了多个线程调用get的情况。

```java
 public static void main(String[] args) throws ExecutionException, InterruptedException {
     System.out.println("Start:" + System.nanoTime());
     FutureTask<Long> futureTask = new FutureTask<Long>(new SumTask());
     Executor executor=Executors.newSingleThreadExecutor();
     executor.execute(futureTask);
     for(int i=0;i<5;i++){
         executor.execute(new Runnable() {
             @Override
             public void run() {
                 try {
                     System.out.println("get result "+futureTask.get());
                 } catch (InterruptedException e) {
                     e.printStackTrace();
                 } catch (ExecutionException e) {
                     e.printStackTrace();
                 }
             }
         });
     }
     System.out.println(futureTask.get());
     System.out.println("End:" + System.nanoTime());
 }
```

该例子展示了一共有5个线程想得到FutureTask的结果，一旦调用get，那么该线程就会阻塞。 
FutureTask的get方法实现如下：

```java
 public V get() throws InterruptedException, ExecutionException {
     int s = state;
     if (s <= COMPLETING)
         s = awaitDone(false, 0L);
     return report(s);
 }
```

从上面的代码可以看到，如果当前任务的状态不大于COMPLETING，那么会调用awaitDone方法，这个方法会将调用的线程挂起；否则直接调用report方法返回结果。 
在前面set和setException方法中可以得出结论：当状态从NEW变为COMPLETING后，才会将outcome赋值，也就是状态是NEW或者COMPLETING时，outcome都还未赋值，也就意味着计算仍在进行，那么此时想要get到结果，就必须等待。下面先看下awaitDone方法是如何将调用线程阻塞的。awaitDone的两个参数分别表示是否定时，以及定时的时间多少。get的另一个重载方法就提供了超时限制。awaitDone方法如下：

````java
private int awaitDone(boolean timed, long nanos)
    throws InterruptedException {
    final long deadline = timed ? System.nanoTime() + nanos : 0L;
    WaitNode q = null;
    boolean queued = false;
    for (;;) {
        //如果当前线程被中断了，移除并抛出异常
        if (Thread.interrupted()) {
            removeWaiter(q);
            throw new InterruptedException();
        }

        int s = state;
        //如果状态大于COMPLETING，说明已经计算已经完成了
        if (s > COMPLETING) {
            if (q != null)
                q.thread = null;
            return s;
        }
        //状态是COMPLETING，在set和setException方法中可以看到处于该状态马上就会进入下一个状态
        else if (s == COMPLETING) // cannot time out yet
            Thread.yield();  //暂停当前正在执行的线程对象
        //新建一个等待节点
        else if (q == null)
            q = new WaitNode();
        //还没有入队，尝试入队
        else if (!queued)
            queued = UNSAFE.compareAndSwapObject(this, waitersOffset,
                                                 q.next = waiters, q);
        //如果限制了时间
        else if (timed) {
            nanos = deadline - System.nanoTime();
            if (nanos <= 0L) {
                removeWaiter(q);
                return state;
            }
            //挂起指定时间
            LockSupport.parkNanos(this, nanos);
        }
        //无限挂起
        else
            LockSupport.park(this);
    }
}
````

上面的代码中有一个WaitNode类，该类表示等待节点，保存等待的线程以及下一个节点，是一个单链表结构，其定义如下:

````java
 static final class WaitNode {
     volatile Thread thread;
     volatile WaitNode next;
     WaitNode() { thread = Thread.currentThread(); }
 }
````

awaitDone方法中进入死循环后，主要有几步： 

1. 如果线程被中断了，移除节点，抛出异常 
2. 如果状态大于COMPLETING，那么直接返回 
3. 如果状态是COMPLETING，在set和setException可以看到，处于COMPLETING是一个暂时状态，很快就会进入下一个状态，所以这儿就调用了Thread.yield()方法让步一下 
4. 如果状态是NEW且节点为null，那么创建一个节点
5. 如果还没有将当前线程加入队列，那么将当前线程加入到等待队列中。由于WaitNode是一个单链表结构，FutureTask中保存了waiters的变量，就可以沿着该变量得到所有等待的线程 
6. 如果限制了时间，那么计算出生出超出时间，挂起指定时间。当解除挂起时，如果计算还未完成，那么将会由于没有时间了，调用removeWaiter方法移除节点。
7. 如果没有限制时间，那么将线程无限挂起

上面几种情况下，都涉及了移除节点，removeWaiter方法就是删除单链表中一个节点的实现。 
当线程被解除挂起，或计算已经完成后，将会get方法中将会调用report返回结果，其实现如下：

````java
 private V report(int s) throws ExecutionException {
     Object x = outcome;
     //如果计算正常结束
     if (s == NORMAL)
         return (V)x;
     //如果计算被取消了
     if (s >= CANCELLED)
         throw new CancellationException();
     //如果计算以异常计算
     throw new ExecutionException((Throwable)x);
 }
````

从上面可以看到report会根据任务的状态不同返回不同的结果。 

- 如果计算正常结束，即状态是NORMAL，那么返回正确的计算结果 
- 如果计算被取消了，即状态大于等于CANCELLED，那么抛出CancellationException 
- 如果计算以异常结束，即状态是EXCEPTIONAL，那么抛出ExecutionException

#### finishCompletion方法

在set方法和setException方法中，当将结果赋值后，都调用了finishCompletion方法来移除和通知等待线程。由于get方法中可以挂起了一群等待节点，那么当结果被计算出来了，自然应该通知那些等待线程。finishCompletion的实现如下：

````java
 private void finishCompletion() {
     //如果有等待线程，从头开始解除挂起
     for (WaitNode q; (q = waiters) != null;) {
         if (UNSAFE.compareAndSwapObject(this, waitersOffset, q, null)) {
             for (;;) {
                 //得到等待节点的线程，解除挂起
                 Thread t = q.thread;
                 if (t != null) {
                     q.thread = null;
                     LockSupport.unpark(t);
                 }
                 WaitNode next = q.next;
                 if (next == null)
                     break;
                 q.next = null; // unlink to help gc
                 q = next;
             }
             break;
         }
     }

     done();

     callable = null;        // to reduce footprint
 }
````

finishCompletion的实现比较简单，就是遍历等待线程的单链表，释放那些等待线程。当线程被释放后，那么在awaitDone的死循环中就会进入下一个循环，由于状态已经变成了NORMAL或者EXCEPTIONAL，将会直接跳出循环。 
释放了所有线程后，将会调用done()方法，FutureTask的done()方法默认没有任何实现，子类可以在该方法中调用完成回调以及记录操作等等。 
上面的方法分析完了FutureTask的主要流程，包括调用get线程的阻塞、run方法执行、计算结果的返回。下面再来看一些取消、查看状态的方法。

#### cancel方法

cancel方法用于取消Callable的计算。参数mayInterruptIfRunning指明是否应该中断正在运行的任务，返回值表示取消是否成功了。其源码如下：

````java
 public boolean cancel(boolean mayInterruptIfRunning) {
     if (!(state == NEW &&
           UNSAFE.compareAndSwapInt(this, stateOffset, NEW,
                                    mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))
         return false;
     try { 
         //如果需要中断
         if (mayInterruptIfRunning) {
             try {
                 Thread t = runner;
                 if (t != null)
                     t.interrupt();
             } finally {
                 //最终状态INTERRUPTED
                 UNSAFE.putOrderedInt(this, stateOffset, INTERRUPTED);
             }
         }
     } finally {
         //释放等待线程
         finishCompletion();
     }
     return true;
 }
````

从上面可以看到如果是需要中断正在执行的任务，那么状态转换将会是NEW->INTERRPUTING->INTERRUPTED；如果不需要中断正在执行的任务，那么状态转换将会是NEW->CANCELD。不管是否中断，最终都会调用finishCompletion()完成对等待线程的释放。 
当这些线程释放后，再进入到awaitDone中的循环时，返回的状态将会是大于等于CANCELD，在report方法中将会得到CancellationException异常。

#### isDone方法

Future接口中isDone方法表明任务是否已经完成了，如果完成了，那么返回true，否则false。下面是FutureTask的实现：

````java
 public boolean isDone() {
     return state != NEW;
 }
````

可以看到只要状态从初始状态NEW完成了一次转换，那么就说明任务已经被完成了。

## Lamda表达式

- 避免匿名内部类定义过多;
- 可以让你的代码看起来很简洁;
- 去掉了一堆没有意义的代码，只留下核心的逻辑。

````java
public class Lamda2 {
    //3.静态内部类
    static class Love2 implements Ilove{
        @Override
        public void love(int a) {
            System.out.println("i love "+a);
        }
    }

    public static void main(String[] args) {
        Ilove love = new Love();
        love.love(1);

        love = new Love2();
        love.love(2);

        //4.局部内部类
        class love3 implements Ilove{
            @Override
            public void love(int a) {
                System.out.println("i love "+a);
            }
        }
        love = new love3();
        love.love(3);

        //5.匿名内部类
        love = new Ilove() {
            @Override
            public void love(int a) {
                System.out.println("i love "+a);
            }
        };
        love.love(4);

        //6.lamda简化
        love = (int a) -> {
            System.out.println("i love "+a);
        };
        love.love(5);

        //6.lamda简化1,去除参数类型（多个参数都需要去除）
        love = (a) -> {
            System.out.println("i love "+a);
        };
        love.love(6);

        //6.lamda简化2,去除括号（多参数不允许删除）
        love = a -> {
            System.out.println("i love "+a);
        };
        love.love(7);

        //6.lamda简化3,去除花括号（多行代码不允许删除）
        love = a -> System.out.println("i love "+a);

        love.love(8);

    }
}

//1.定义一个函数式接口：接口只有一个方法（lamda表达式只能是函数式接口）
interface Ilove{
    void love(int a);
}

//2.实现类
class Love implements Ilove{
    @Override
    public void love(int a) {
        System.out.println("i love "+a);
    }
}
````

# 线程状态

![image-20220712163722673](G:\Agogogo2022\project\studyNotes\notes\伟\JavaSE\pictures\image-20220712163722673.png)

![image-20220712164344662](G:\Agogogo2022\project\studyNotes\notes\伟\JavaSE\pictures\image-20220712164344662.png)

## 方法

| 方法                           | 说明                                       |
| :----------------------------- | :----------------------------------------- |
| setPriority(int newPriority)   | 更改线程的优先级                           |
| static void sleep(long millis) | 在指定的毫秒数内让当前正在执行的线程休眠   |
| void join()                    | 等待该线程终止                             |
| static void yield()            | 暂停当前正在执行的线程对象，并执行其他线程 |
| void interrupt()               | 中断线程（别用这个方式）                   |
| boolean isAlive(               | 测试线程是否处于活动状态                   |

## 停止线程

- 不推荐使用JDK提供的 stop()、 destroy()方法。【已废弃】
- 推荐线程自己停止下来
- 建议使用一个标志位进行终止变量 当flag=false，则终止线程运行。

```java
public class ThreadStop implements Runnable{
    //1.线程中定义线程体使用的标识
    private boolean flag = true;
    @Override
    public void run() {
        int i=0;
        //2.线程体使用该标识
        while (flag){
            System.out.println("thread run "+i++);
        }
    }

    //3.对外提供方法改变标识
    public void stop(){
        this.flag = false;
    }

    public static void main(String[] args) {
        ThreadStop threadStop = new ThreadStop();
        new Thread(threadStop).start();

        for (int i = 0; i < 1000; i++) {
            System.out.println("main "+i);
            if(i == 900){
                threadStop.stop();
            }
        }
    }
}
```

## 线程休眠

- sleep (时间) 指定当前线程阻塞的毫秒数；
- sleep存在异常InterruptedException；
- sleep时间达到后线程进入就绪状态；
- sleep可以模拟网络延时，倒计时等；
- 每一个对象都有一个锁，sleep不会释放锁

```java
public class ThreadSleep implements Runnable{

    //每隔一秒打印一次时间
    @Override
    public void run() {
        Date date = new Date(System.currentTimeMillis());
        while (true){
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(new SimpleDateFormat("HH:mm:ss").format(date));
            date = new Date(System.currentTimeMillis());
        }

    }

    public static void main(String[] args) {
        ThreadSleep threadSleep = new ThreadSleep();
        new Thread(threadSleep).start();
    }
}
```

## 线程礼让

- 礼让线程，让当前正在执行的线程暂停，但不阻塞
- 将线程从运行状态转为就绪状态
- **让cpu重新调度，礼让不一定成功！看CPU心情**

````java
public class ThreadYield {
    public static void main(String[] args) {
        MyYield myYield = new MyYield();
        new Thread(myYield,"a").start();
        new Thread(myYield,"b").start();
    }
}

class MyYield implements Runnable{
    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName()+"执行开始");
        //线程礼让
        Thread.yield();
        System.out.println(Thread.currentThread().getName()+"执行结束");
    }
}
````

## join

- Join合并线程，待此线程执行完成后，再执行其他线程，其他线程阻塞
- 可以想象成插队

```java
public class ThreadJoin implements Runnable{
    @Override
    public void run() {
        for (int i = 0; i < 1000; i++) {
            System.out.println("vip来了"+i);
        }
    }

    public static void main(String[] args) {
        ThreadJoin threadJoin = new ThreadJoin();
        Thread thread = new  Thread(threadJoin);
        thread.start();

        for (int i = 0; i < 500; i++) {
            System.out.println("main"+i);
            //200前随机执行main和thread线程
            //200后执行完tread再执行main
            if(i == 200){
                try {
                    thread.join();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
```

## 线程状态

![image-20220712171215284](G:\Agogogo2022\project\studyNotes\notes\伟\JavaSE\pictures\image-20220712171215284.png)

```java
public class ThreadStatus {
    public static void main(String[] args) throws InterruptedException {
        Thread thread = new Thread(()->{
            for (int i = 0; i < 5; i++) {
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            System.out.println("//////////");
        });

        //观察状态
        Thread.State state = thread.getState();
        System.out.println(state);

        thread.start();
        state = thread.getState();
        System.out.println(state);

        while (state != Thread.State.TERMINATED){
            Thread.sleep(100);
            state = thread.getState();
            System.out.println(state);
        }

    }
}

/**
结果：
NEW             初始化
RUNNABLE        执行中
TIMED_WAITING   等待时间
TIMED_WAITING   等待时间
...
TIMED_WAITING   等待时间
//////////   
TERMINATED      结束
**/
```

## 线程优先级

- Java提供一个线程调度器来监控程序中启动后进入就绪状态的所有线程，线程调度器按照优先级决定应该调度哪个线程来执行。
  - 优先级低只是意味着获得调度的概率低.并不是优先级低就不会被调用了.这都是看CPU的调度

- 线程的优先级用数字表示，范围从1~10。
  - Thread.MIN_PRIORITY = 1;
  - Thread.MAX_PRIORITY = 10;
  - Thread.NORM_PRIORITY = 5;
- 使用以下方式改变或获取优先级
  - setPriority(int xxx)
  - getPriority()
  - 优先级的设定建议在start()调度前

```java
public class TheardPriority {
    public static void main(String[] args) {
        System.out.println(Thread.currentThread().getName()+"优先级"+Thread.currentThread().getPriority());

        MyPriority myPriority = new MyPriority();
        Thread t1 = new Thread(myPriority);
        Thread t2 = new Thread(myPriority);
        Thread t3 = new Thread(myPriority);
        Thread t4 = new Thread(myPriority);
        Thread t5 = new Thread(myPriority);
        Thread t6 = new Thread(myPriority);

        t1.start();

        t2.setPriority(1);
        t2.start();
        t3.setPriority(4);
        t3.start();
        t4.setPriority(Thread.MAX_PRIORITY);
        t4.start();
        t5.setPriority(8);
        t5.start();
        t6.setPriority(7);
        t6.start();

    }
}

class MyPriority implements Runnable{
    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName()+"优先级"+Thread.currentThread().getPriority());
    }
}

/**
结果：
main优先级5
Thread-3优先级10
Thread-4优先级8
Thread-5优先级7
Thread-0优先级5
Thread-2优先级4
Thread-1优先级1
**/
```

## 守护(daemon)线程

- 线程分为用户线程和守护线程
- 虚拟机必须确保用户线程执行完毕
- 虚拟机不用等待守护线程执行完毕，如后台记录操作日志,监控内存,垃圾回收等

```java
public class TheardDaemon {
    public static void main(String[] args) {
        Thread gThread = new Thread(new God());
        Thread yThread = new Thread(new You());

        gThread.setDaemon(true);
        gThread.start();
        yThread.start();

    }
}

class God implements Runnable{
    @Override
    public void run() {
        while (true){
            System.out.println("上帝守护你");
        }
    }
}
class You implements Runnable{
    @Override
    public void run() {
        for (int i = 0; i < 3; i++) {
            System.out.println("开心"+i);
        }
        System.out.println("结束");
    }
}

/**
结果：
上帝守护你
上帝守护你
上帝守护你
上帝守护你
上帝守护你
开心0
开心1
开心2
结束
**/
```

# 线程同步

- 现实生活中,我们会遇到 ” 同一个资源 , 多个人都想使用” 的问题, 比如,食堂排队打饭 , 每个人都想吃饭 , 最天然的解决办法就是 , 排队. 一个个来.
- 处理多线程问题时 , 多个线程访问同一个对象 , 并且某些线程还想修改这个对象. 这时候我们就需要线程同步 . 线程同步其实就是一种等待机制, 多个需要同时访问此对象的线程进入这个对象的等待池形成队列, 等待前面线程使用完毕, 下一个线程再使用

- 由于同一进程的多个线程共享同一块存储空间 , 在带来方便的同时,也带来了访问冲突问题 , 为了保证数据在方法中被访问时的正确性 , 在访问时加入锁机制**synchronized** , 当一个线程获得对象的排它锁 , 独占资源, 其他线程必须等待, 使用后释放锁即可 . 存在以下问题 :
  - 一个线程持有锁会导致其他所有需要此锁的线程挂起;
  - 在多线程竞争下 , 加锁 , 释放锁会导致比较多的上下文切换和调度延时,引起性能问题 ;
  - 如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置 , 引起性能问题 。

## 同步方式

synchronized的3种使用方式：

- 修饰实例方法：作用于当前实例加锁
- 修饰静态方法：作用于当前类对象加锁
- 修饰代码块：指定加锁对象，对给定对象加锁

![image-20220712174556732](G:\Agogogo2022\project\studyNotes\notes\伟\JavaSE\pictures\image-20220712174556732.png)

### 修饰方法

Synchronized修饰一个方法很简单，就是在方法的前面加synchronized，synchronized修饰方法和修饰一个代码块类似，只是作用范围不一样，修饰代码块是大括号括起来的范围，而修饰方法范围是整个函数。

```java
public synchronized void method()
{
   // todo
}

public void method()
{
   synchronized(this) {
      // todo
   }
}
```

synchronized关键字不能继承。 虽然可以使用synchronized来定义方法，但synchronized并不属于方法定义的一部分，因此，synchronized关键字不能被继承。如果在父类中的某个方法使用了synchronized关键字，而在子类中覆盖了这个方法，在子类中的这个方法默认情况下并不是同步的，而必须显式地在子类的这个方法中加上synchronized关键字才可以。当然，还可以在子类方法中调用父类中相应的方法，这样虽然子类中的方法不是同步的，但子类调用了父类的同步方法，因此，子类的方法也就相当于同步了。这两种方式的例子代码如下：

```java
//在子类方法中加上synchronized关键字
class Parent {
   public synchronized void method() { }
}
class Child extends Parent {
   public synchronized void method() { }
}

//在子类方法中调用父类的同步方法
class Parent {
   public synchronized void method() {   }
}
class Child extends Parent {
   public void method() { super.method();   }
} 
```

**注意：**

- 在定义接口方法时不能使用synchronized关键字。
- 构造方法不能使用synchronized关键字，但可以使用synchronized代码块来进行同步。

### 修饰代码块

- 一个线程访问一个对象中的synchronized(this)同步代码块时，其他试图访问该对象的线程将被阻塞。

````java
class SyncThread implements Runnable {
       private static int count;
 
       public SyncThread() {
          count = 0;
       }
 
       public  void run() {
          synchronized(this) {
             for (int i = 0; i < 5; i++) {
                try {
                   System.out.println(Thread.currentThread().getName() + ":" + (count++));
                   Thread.sleep(100);
                } catch (InterruptedException e) {
                   e.printStackTrace();
                }
             }
          }
       }
 
       public int getCount() {
          return count;
       }
}
 
public class Demo00 {
    public static void main(String args[]){
　　　　//调用方式一：test01
　　　　//SyncThread s1 = new SyncThread();
　　　　//SyncThread s2 = new SyncThread();
　　　　//Thread t1 = new Thread(s1);
　　　　//Thread t2 = new Thread(s2);
　　　　//调用方式二：test02        
        SyncThread s = new SyncThread();
        Thread t1 = new Thread(s);
        Thread t2 = new Thread(s);
        
        t1.start();
        t2.start();
    }
}
````

调用方式二种，当两个并发线程(thread1和thread2)访问同一个对象(syncThread)中的synchronized代码块时，在同一时刻只能有一个线程得到执行，另一个线程受阻塞，必须等待当前线程执行完这个代码块以后才能执行该代码块。Thread1和thread2是互斥的，因为在执行synchronized代码块时会锁定当前的对象，只有执行完该代码块才能释放该对象锁，下一个线程才能执行并锁定该对象

调用方式一中，thread1和thread2同时在执行。这是因为synchronized只锁定对象，每个对象只有一个锁（lock）与之相关联。

- 一个线程访问一个对象的synchronized代码块时，别的线程可以访问该对象的非synchronized代码块而不受阻塞。

```java
class Counter implements Runnable{
   private int count;
 
   public Counter() {
      count = 0;
   }
 
   public void countAdd() {
      synchronized(this) {
         for (int i = 0; i < 5; i ++) {
            try {
               System.out.println(Thread.currentThread().getName() + ":" + (count++));
               Thread.sleep(100);
            } catch (InterruptedException e) {
               e.printStackTrace();
            }
         }
      }
   }
 
   //非synchronized代码块，未对count进行读写操作，所以可以不用synchronized
   public void printCount() {
      for (int i = 0; i < 5; i ++) {
         try {
            System.out.println(Thread.currentThread().getName() + " count:" + count);
            Thread.sleep(100);
         } catch (InterruptedException e) {
            e.printStackTrace();
         }
      }
   }
 
   public void run() {
      String threadName = Thread.currentThread().getName();
      if (threadName.equals("A")) {
         countAdd();
      } else if (threadName.equals("B")) {
         printCount();
      }
   }
}
 
public class Demo00{
    public static void main(String args[]){
        Counter counter = new Counter();
        Thread thread1 = new Thread(counter, "A");
        Thread thread2 = new Thread(counter, "B");
        thread1.start();
        thread2.start();
    }
}
```

可以看见B线程的调用是非synchronized,并不影响A线程对synchronized部分的调用。

- 指定要给某个对象加锁

```java
/**
 * 银行账户类
 */
class Account {
   String name;
   float amount;
 
   public Account(String name, float amount) {
      this.name = name;
      this.amount = amount;
   }
   //存钱
   public  void deposit(float amt) {
      amount += amt;
      try {
         Thread.sleep(100);
      } catch (InterruptedException e) {
         e.printStackTrace();
      }
   }
   //取钱
   public  void withdraw(float amt) {
      amount -= amt;
      try {
         Thread.sleep(100);
      } catch (InterruptedException e) {
         e.printStackTrace();
      }
   }
 
   public float getBalance() {
      return amount;
   }
}
 
/**
 * 账户操作类
 */
class AccountOperator implements Runnable{
   private Account account;
   public AccountOperator(Account account) {
      this.account = account;
   }
 
   public void run() {
      synchronized (account) {
         account.deposit(500);
         account.withdraw(500);
         System.out.println(Thread.currentThread().getName() + ":" + account.getBalance());
      }
   }
}
 
public class Demo00{
    
    //public static final Object signal = new Object(); // 线程间通信变量
    //将account改为Demo00.signal也能实现线程同步
    public static void main(String args[]){
        Account account = new Account("zhang san", 10000.0f);
        AccountOperator accountOperator = new AccountOperator(account);
 
        final int THREAD_NUM = 5;
        Thread threads[] = new Thread[THREAD_NUM];
        for (int i = 0; i < THREAD_NUM; i ++) {
           threads[i] = new Thread(accountOperator, "Thread" + i);
           threads[i].start();
        }
    }
}
```

在AccountOperator 类中的run方法里，我们用synchronized 给account对象加了锁。这时，当一个线程访问account对象时，其他试图访问account对象的线程将会阻塞，直到该线程访问account对象结束。也就是说谁拿到那个锁谁就可以运行它所控制的那段代码。 

### 修改静态方法

静态方法是属于类的而不属于对象的。同样的，synchronized修饰的静态方法锁定的是这个类的所有对象。

```java
/**
 * 同步线程
 */
class SyncThread implements Runnable {
   private static int count;
 
   public SyncThread() {
      count = 0;
   }
 
   public synchronized static void method() {
      for (int i = 0; i < 5; i ++) {
         try {
            System.out.println(Thread.currentThread().getName() + ":" + (count++));
            Thread.sleep(100);
         } catch (InterruptedException e) {
            e.printStackTrace();
         }
      }
   }
 
   public synchronized void run() {
      method();
   }
}
 
public class Demo00{
    
    public static void main(String args[]){
        SyncThread syncThread1 = new SyncThread();
        SyncThread syncThread2 = new SyncThread();
        Thread thread1 = new Thread(syncThread1, "SyncThread1");
        Thread thread2 = new Thread(syncThread2, "SyncThread2");
        thread1.start();
        thread2.start();
    }
}
```

syncThread1和syncThread2是SyncThread的两个对象，但在thread1和thread2并发执行时却保持了线程同步。这是因为run中调用了静态方法method，而静态方法是属于类的，所以syncThread1和syncThread2相当于用了同一把锁。

### 修饰一个类

给class加锁和上例的给静态方法加锁是一样的，所有对象公用一把锁。

```java
/**
 * 同步线程
 */
class SyncThread implements Runnable {
   private static int count;
 
   public SyncThread() {
      count = 0;
   }
 
   public static void method() {
      synchronized(SyncThread.class) {
         for (int i = 0; i < 5; i ++) {
            try {
               System.out.println(Thread.currentThread().getName() + ":" + (count++));
               Thread.sleep(100);
            } catch (InterruptedException e) {
               e.printStackTrace();
            }
         }
      }
   }
 
   public synchronized void run() {
      method();
   }
}
```

### 总结

- 无论synchronized关键字加在方法上还是对象上，如果它作用的对象是非静态的，则它取得的锁是对象；如果synchronized作用的对象是一个静态方法或一个类，则它取得的锁是对类，该类所有的对象同一把锁。 
- 每个对象只有一个锁（lock）与之相关联，谁拿到这个锁谁就可以运行它所控制的那段代码。 
- 实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。

## 死锁

多个线程各自占有一些共享资源 , 并且互相等待其他线程占有的资源才能运行, 而导致两个或者多个线程都在等待对方释放资源 , 都停止执行的情形. 某一个同步块同时拥有 “ 两个以上对象的锁 ” 时 , 就可能会发生 “ 死锁” 的问题。

**避免方法：**

1. 互斥条件：一个资源每次只能被一个进程使用。
2. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
3. 不剥夺条件 : 进程已获得的资源，在末使用完之前，不能强行剥夺。
4. 循环等待条件 : 若干进程之间形成一种头尾相接的循环等待资源关系。

## Lock锁

- 从JDK 5.0开始，Java提供了更强大的线程同步机制——通过显式定义同步锁对象来实现同步。同步锁使用Lock对象充当
- java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具。锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象 
- ReentrantLock 类实现了 Lock ，它拥有与 synchronized 相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是ReentrantLock，可以显式加锁、释放锁。

```JAVA
class A{
    private final ReentrantLock lock = new ReenTrantLock();
    public void m(){
        lock.lock();
        try{
        	//保证线程安全的代码;
        }
        finally{
            lock.unlock();
            //如果同步代码有异常，要将unlock()写入finally语句块
        }
    }
}
```

## synchronized 与 Lock 的对比

- Lock是显式锁（手动开启和关闭锁，别忘记关闭锁）synchronized是隐式锁，出了作用域自动释放 
- Lock只有代码块锁，synchronized有代码块锁和方法锁
- 使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多的子类） 
- 优先使用顺序： Lock > 同步代码块（已经进入了方法体，分配了相应资源）> 同步方法（在方法体之外）

# 线程通信

| 方法名             | 作用                                                         |
| ------------------ | ------------------------------------------------------------ |
| wait()             | 表示线程一直等待 , 直到其他线程通知, 与sleep不同, 会释放锁   |
| wait(long timeout) | 指定等待的毫秒数                                             |
| notify()           | 唤醒一个处于等待状态的线程                                   |
| notifyAll()        | 唤醒同一个对象上所有调用wait()方法的线程, 优先级别高的线程优先调度 |

## 线程间通信案例

通信是在不同线程间的通信，一个线程处于`wait`状态阻塞等待被唤醒，另一个线程通过`notify`或者`notifyAll`唤醒，当前的唤醒操作必须是作用与同一个对象，注意在进行唤醒和阻塞时必须要加锁的，加锁需要使用`synchronized`关键字。

**WaitDemo类**

```java
public class WaitDemo extends Thread{
    private Object obj;

    public WaitDemo(Object obj) {
        this.obj = obj;
    }

    @Override
    public void run() {
        synchronized (obj) {
            System.out.println(Thread.currentThread().getName() + "WaitDemo执行开始~~~");
            try {
                obj.wait(); //调用wait方法阻塞线程执行
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName() + "WaitDemo执行结束~~~");
        }
    }
}
```

**NotifyDemo类**

```java
public class NotifyDemo extends Thread{
    private Object obj;

    public NotifyDemo(Object obj) {
        this.obj = obj;
    }

    @Override
    public void run() {
        synchronized (obj) {
            System.out.println(Thread.currentThread().getName() + "NotifyDemo执行开始~~~");
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            obj.notify(); //调用notify方法唤醒阻塞线程
            System.out.println(Thread.currentThread().getName() + "NotifyDemo执行结束~~~");
        }
    }
}
```

**TestWaitAndNotify测试类**

```java
public class TestWaitAndNotify {
    public static void main(String[] args) {
        Object object = new Object();
        WaitDemo waitDemo = new WaitDemo(object);
        NotifyDemo notifyDemo = new NotifyDemo(object);

        waitDemo.setName("WaitDemo线程");
        notifyDemo.setName("NotifyDemo线程");

        waitDemo.start();
        notifyDemo.start();

    }
}
```

![image-20220718114521912](G:\Agogogo2022\project\studyNotes\notes\伟\JavaSE\pictures\image-20220718114521912.png)

## 注意点

- 调用notify和wait方法必须是作用于同一个对象，如果不是通一个对象则无法完成通信。
- 对于wait、nitify、notifyAll的调用，必须在该对象的同步方法或者代码块中，锁作用的对象和wait等方法必须是作用于同一个对象。
- wait方法在调用后进入阻塞之前会释放锁，而sleep和join是不会释放锁的。
- 线程状态转换时，当wait被唤醒或者超时时，线程并不是直接进入就绪状态，而是先进入阻塞状态，抢锁成功后才能进入到可运行状态。

**注意点1** 当锁的对象和调用`wait`、`notify`的对象不是同一个对象时，会抛出`IllegalMonitorStateException`异常。

![image-20220718114841912](G:\Agogogo2022\project\studyNotes\notes\伟\JavaSE\pictures\image-20220718114841912.png)

**注意点2** `wait`方法在调用进入阻塞之前会释放锁

![image-20220718114949974](G:\Agogogo2022\project\studyNotes\notes\伟\JavaSE\pictures\image-20220718114949974.png)

基于以上分析，一旦wait线程先调用则线程因为锁无法继续执行而阻塞下来，实际上notify依然可以获取锁进行执行，这是因为**wait方法在调用进入阻塞之前释放锁**，则调用notify操作的线程就可以抢到Object对象的锁，进而调用notify。

**注意点3** **锁池和等待池**

锁池：假设线程A已经拥有了某个对象的锁，而其他的线程想要调用这个对象的某个synchronized方法，由于这些线程在进入对象的synchronized方法之前必须先获取该对象的锁的拥有权，但是该对象的锁目前被线程A拥有，所以这些线程就回去进入到该对象的锁池
等待池：假设一个线程A调用某个对象的wait方法，线程A就会释放该对象的锁后，进入到该对象的等待池

## 示例

```java
//有三个线程，分别为ABC线程，需要线程交替打印：ABCABC…打印10遍
//分析：需要使用线程间的通信，A给B通信，A进行notifyB进行wait；B给C通信，B进行notifyC进行Wait；同理C给A通信，C进行notifyA进行wait。
//给每个线程给定编号，表明是第几个进程，再给定一个共享对象，共享对象进行notify、wait等操作，
//共享对象本身需要携带信息表明下一个执行的线程编号，如果当前线程的编号与共享对象中的信息比较，如果相等就执行，否则就阻塞。

public class ThreadTongXin {
    public static void main(String[] args) {
        NextOpt nextOpt = new NextOpt();
        nextOpt.setNextValue(0);
        ThreadMain threadMain1 = new ThreadMain(nextOpt, 0);
        ThreadMain threadMain2 = new ThreadMain(nextOpt, 1);
        ThreadMain threadMain3 = new ThreadMain(nextOpt, 2);
        new Thread(threadMain1,"1").start();
        new Thread(threadMain2,"2").start();
        new Thread(threadMain3,"3").start();
    }
}

//先创建个共享对象,携带下一个线程编号信息
class NextOpt{
    //下一个线程编号
    private Integer nextValue;

    public Integer getNextValue() {
        return nextValue;
    }

    public void setNextValue(Integer nextValue) {
        this.nextValue = nextValue;
    }
}

//线程执行类
class ThreadMain implements Runnable{
    //共享对象
    private NextOpt nextOpt;

    //打印名称从数组获取
    String[] arr= {"A","B","C"};

    //线程编号
    private int index;

    //执行次数
    int count = 0;

    public ThreadMain(NextOpt nextOpt,int index) {
        this.nextOpt = nextOpt;
        this.index = index;
    }

    @Override
    public void run() {
        while (true){
            //同步共享对象
            synchronized (nextOpt){
                //下一线程编号不是本线程编号，阻塞
                while (nextOpt.getNextValue() != index){
                    try {
                        nextOpt.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }

                //打印
                System.out.println(Thread.currentThread().getName()+":"+arr[index]);

                //指定下一个线程编号
                nextOpt.setNextValue((index+1)%3);

                //唤醒所有阻塞线程
                nextOpt.notifyAll();

                //计数
                if (count++>9){
                    break;
                }
            }
        }
    }
}
```



# 线程池

java中经常需要用到多线程来处理一些业务，我们非常不建议单纯使用继承Thread或者实现Runnable接口的方式来创建线程，那样势必有创建及销毁线程耗费资源、线程上下文切换问题。同时创建过多的线程也可能引发资源耗尽的风险，这个时候引入线程池比较合理，方便线程任务的管理。java中涉及到线程池的相关类均在jdk1.5开始的java.util.concurrent包中，涉及到的几个核心类及接口包括：Executor、Executors、ExecutorService、ThreadPoolExecutor、FutureTask、Callable、Runnable等。

## **Executors**

Executors创建线程池方法：

| 方法名                           | 功能                                                       |
| -------------------------------- | ---------------------------------------------------------- |
| newFixedThreadPool(int nThreads) | 创建固定大小的线程池                                       |
| newSingleThreadExecutor()        | 创建只有一个线程的线程池                                   |
| newCachedThreadPool()            | 创建一个不限线程数上限的线程池，任何提交的任务都将立即执行 |

创建线程池应该直接使用`ThreadPoolExecutor`的构造方法。没错，上述`Executors`方法创建的线程池就是`ThreadPoolExecutor`。

## **ThreadPoolExecutor**

### 构造方法

`Executors`中创建线程池的快捷方法，实际上是调用了`ThreadPoolExecutor`的构造方法（定时任务使用的是`ScheduledThreadPoolExecutor`），该类构造方法参数列表如下：

```java
// Java线程池的完整构造函数
public ThreadPoolExecutor(
  int corePoolSize, // 线程池长期维持的线程数，即使线程处于Idle状态，也不会回收。
  int maximumPoolSize, // 线程数的上限
  long keepAliveTime, TimeUnit unit, // 超过corePoolSize的线程的idle时长，
                                     // 超过这个时间，多余的线程会被回收。
  BlockingQueue<Runnable> workQueue, // 任务的排队队列
  ThreadFactory threadFactory, // 新线程的产生方式
  RejectedExecutionHandler handler) // 拒绝策略
```

有7个参数，这些参数中，比较容易引起问题的有`corePoolSize`, `maximumPoolSize`, `workQueue`以及`handler`：

- `corePoolSize`和`maximumPoolSize`设置不当会影响效率，甚至耗尽线程；
- `workQueue`设置不当容易导致OOM（内存不足）；
- `handler`设置不当会导致提交任务时抛出异常。

### **参数详解**

- `corePoolSize`：核心线程数，也是线程池中常驻的线程数，线程池初始化时默认是没有线程的，当任务来临时才开始创建线程去执行任务

- `maximumPoolSize`：最大线程数，在核心线程数的基础上可能会额外增加一些非核心线程，需要注意的是只有当workQueue队列填满时才会创建多于corePoolSize的线程(线程池总线程数不超过maxPoolSize)

- `keepAliveTime`：非核心线程的空闲时间超过keepAliveTime就会被自动终止回收掉，注意当corePoolSize=maxPoolSize时，keepAliveTime参数也就不起作用了(因为不存在非核心线程)；

- `unit`：keepAliveTime的时间单位

- `workQueue`：用于保存任务的队列，可以为无界、有界、同步移交三种队列类型之一，当池子里的工作线程数大于corePoolSize时，这时新进来的任务会被放到队列中

- `threadFactory`：创建线程的工厂类，默认使用Executors.defaultThreadFactory()，也可以使用guava库的ThreadFactoryBuilder来创建

- `handler`：线程池无法继续接收任务(队列已满且线程数达到maximunPoolSize)时的饱和策略，取值有AbortPolicy、CallerRunsPolicy、DiscardOldestPolicy、DiscardPolicy

### 线程池的线程创建流程

![image-20220718144856011](G:\Agogogo2022\project\studyNotes\notes\伟\JavaSE\pictures\image-20220718144856011.png)

举个栗子：现有一个线程池，corePoolSize=10，maxPoolSize=20，队列长度为100，那么当任务过来会先创建10个核心线程数，接下来进来的任务会进入到队列中直到队列满了，会创建额外的线程来执行任务(最多20个线程)，这个时候如果再来任务就会执行拒绝策略

### **workQueue队列**

- SynchronousQueue(同步移交队列)：队列不作为任务的缓冲方式，可以简单理解为队列长度为零
- LinkedBlockingQueue(无界队列)：队列长度不受限制，当请求越来越多时(任务处理速度跟不上任务提交速度造成请求堆积)可能导致内存占用过多或OOM
- ArrayBlockintQueue(有界队列)：队列长度受限，当队列满了就需要创建多余的线程来执行任务

###  **handler拒绝策略**

- AbortPolicy：中断抛出异常
- DiscardPolicy：默默丢弃任务，不进行任何通知
- DiscardOldestPolicy：丢弃掉在队列中存在时间最久的任务
- CallerRunsPolicy：让提交任务的线程去执行任务(对比前三种比较友好一丢丢)

## 创建线程池方式

**newFixedThreadPool：**

使用的构造方式为new ThreadPoolExecutor(var0, var0, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue())，设置了corePoolSize=maxPoolSize，keepAliveTime=0(此时该参数没作用)，无界队列，任务可以无限放入，当请求过多时(任务处理速度跟不上任务提交速度造成请求堆积)可能导致占用过多内存或直接导致OOM异常

**newSingleThreadExector：**

使用的构造方式为new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue(), var0)，基本同newFixedThreadPool，但是将线程数设置为了1，单线程，弊端和newFixedThreadPool一致

**newCachedThreadPool：**

使用的构造方式为new ThreadPoolExecutor(0, 2147483647, 60L, TimeUnit.SECONDS, new SynchronousQueue())，corePoolSize=0，maxPoolSize为很大的数，同步移交队列，也就是说不维护常驻线程(核心线程)，每次来请求直接创建新线程来处理任务，也不使用队列缓冲，会自动回收多余线程，由于将maxPoolSize设置成Integer.MAX_VALUE，当请求很多时就可能创建过多的线程，导致资源耗尽OOM

**newScheduledThreadPool：**

使用的构造方式为new ThreadPoolExecutor(var1, 2147483647, 0L, TimeUnit.NANOSECONDS, new ScheduledThreadPoolExecutor.DelayedWorkQueue())，支持定时周期性执行，注意一下使用的是延迟队列，弊端同newCachedThreadPool一致

所以根据上面分析我们可以看到，FixedThreadPool和SigleThreadExecutor中之所以用LinkedBlockingQueue无界队列，是因为设置了corePoolSize=maxPoolSize，线程数无法动态扩展，于是就设置了无界阻塞队列来应对不可知的任务量；而CachedThreadPool则使用的是SynchronousQueue同步移交队列，为什么使用这个队列呢？因为CachedThreadPool设置了corePoolSize=0，maxPoolSize=Integer.MAX_VALUE，来一个任务就创建一个线程来执行任务，用不到队列来存储任务；SchduledThreadPool用的是延迟队列DelayedWorkQueue。在实际项目开发中也是推荐使用手动创建线程池的方式，而不用默认方式，关于这点在《阿里巴巴开发规范》中是这样描述的：

![image-20220718145822785](G:\Agogogo2022\project\studyNotes\notes\伟\JavaSE\pictures\image-20220718145822785.png)

## **关闭线程池**

- shutdownNow()：立即关闭线程池(暴力)，正在执行中的及队列中的任务会被中断，同时该方法会返回被中断的队列中的任务列表
- shutdown()：平滑关闭线程池，正在执行中的及队列中的任务能执行完成，后续进来的任务会被执行拒绝策略
- isTerminated()：当正在执行的任务及对列中的任务全部都执行（清空）完就会返回true

## 复用的原理

1. 线程池里执行的是任务,核心逻辑在ThreadPoolExecutor类的execute方法中,同时ThreadPoolExecutor中维护了HashSet<Worker> workers;

2. addWorker()方法来创建线程执行任务,如果是核心线程的任务,会赋值给Worker的firstTask属性;

3. Worker实现了Runnable,本质上也是任务,核心在run()方法里;

4. run()方法的执行核心runWorker(),自旋拿任务while (task != null || (task = getTask()) != null)),task是核心线程Worker的firstTask或者getTask();

5. getTask()的核心逻辑:

   1. 若当前工作线程数量大于核心线程数->说明此线程是非核心工作线程,通过poll()拿任务,未拿到任务即getTask()返回null,然后会在processWorkerExit(w, completedAbruptly)方法释放掉这个非核心工作线程的引用;
   2. 若当前工作线程数量小于核心线程数->说明此时线程是核心工作线程,通过take()拿任务
   3. take()方式取任务,如果队列中没有任务了会调用await()阻塞当前线程,直到新任务到来,所以核心工作线程不会被回收; 当执行execute方法里的workQueue.offer(command)时会调用Condition.singal()方法唤醒一个之前阻塞的线程,这样核心线程即可复用

   ![image-20220718150728873](G:\Agogogo2022\project\studyNotes\notes\伟\JavaSE\pictures\image-20220718150728873.png)

   

## 手动创建线程池(推荐)

上面说了使用Executors工具类创建的线程池有隐患，那如何使用才能避免这个隐患呢？建立自己的线程工厂类，灵活设置关键参数：

```java
//这里默认拒绝策略为AbortPolicy
private static ExecutorService executor = new ThreadPoolExecutor(10,10,60L, TimeUnit.SECONDS,new ArrayBlockingQueue(10));

//使用guava包中的ThreadFactoryBuilder工厂类来构造线程池:
private static ThreadFactory threadFactory = new ThreadFactoryBuilder().build();
private static ExecutorService executorService = new ThreadPoolExecutor(10, 10, 60L, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(10), threadFactory, new ThreadPoolExecutor.AbortPolicy());

//通过guava的ThreadFactory工厂类还可以指定线程组名称，这对于后期定位错误时也是很有帮助的
ThreadFactory threadFactory = new ThreadFactoryBuilder().setNameFormat("thread-pool-d%").build();
```



